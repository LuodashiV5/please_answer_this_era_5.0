 
 
强烈建议，查询相关学习资料要选英文版，这不，一个官方的 Claude Code最佳实践，只有在英文语言下才有。你选择中文，压根看不到。本文基于官方最佳实践文档而来，做了结构化和个人解读，可用于速查和参考，但还是强烈建议读原版内容，毕竟理解的过程才是学习的过程。官方文档见：[https://code.claude.com/docs/en/best-practices]

所有的最佳实践本质上都在围绕一件事在做：上下文管理。不管是 MCP Subagents 还是 Skills，都在做这一件事。

## 底层逻辑：上下文水位管理

**唯一底线**：上下文窗口（Context Window）是 Claude 最昂贵的资源。  
**水位构成**：所有对话历史 + 读取的文件 + Bash 命令输出。  
**物理特性**：窗口越满，Claude 的推理精度和遵循指令的能力越差。

---

## 一、输入策略：按需调取，拒绝预加载

### 核心原则：让 Claude 自己去取，而不是你塞给它

不要手动粘贴代码，优先使用以下方式提供上下文：

- • **精准引用**：使用 `@文件路径` 挂载文件，Claude 会在生成响应前实时
- • **多维输入**：直接粘贴/拖入图片，或提供 URL 供其 fetch 文档（需在 `/permissions` 设置域名白名单）。
- • **数据管道**：利用管道输入，如 `cat error.log | claude`。
- • **工具授权**：告知 Claude 使用 Bash 命令、MCP 工具或文件读取工具。

### 精准投喂指南

| 场景         | ❌ 模糊做法           | ✅ 具体做法                                                    |
| ---------- | ---------------- | --------------------------------------------------------- |
| **添加测试**   | "给 foo.py 添加测试"  | "为 foo.py 编写测试，覆盖用户登出的边界情况。禁止使用 mock。"                    |
| **追溯历史**   | "为什么这个 API 这么怪？" | "查看 ExecutionFactory 的 git 历史，分析其 API 演变逻辑。"              |
| **复用模式**   | "加一个日历组件"        | "参考 HotDogWidget.php 的实现。按相同模式写一个日历组件。"                   |
| **Bug 修复** | "修复登录错误"         | "用户反馈会话超时后无法登录。检查 src/auth/ 的 token 刷新逻辑。写一个复现用例，修复后再验证。" |

---

## 二、执行控制：验证驱动与及时止损

### 1. 验证是最高杠杆（VDD）

当 Claude 能够自我验证时，表现会显著增强：

- • ✅ **运行测试**：强制要求在改动后执行 `npm test` 或 `pytest`。
- • ✅ **图像比对**：改动 UI 后截图，并与原图对比差异。
- • ✅ **输出校验**：检查脚本输出是否符合预期。

### 2. 反馈阻断与重置

- • **`Esc`**：发现跑偏立即终止，节省上下文。
- • **`Esc + Esc` 或 `/rewind`**：快速回滚到之前的对话或代码状态。
- • **`/clear`**：**重置大法**。如果连续两次纠正无效，说明上下文已被污染。立即 `/clear` 并在新会话中整合经验重开。

---

## 三、上下文瘦身：主动减负

### 1. 自动与手动压缩

当接近限制时，Claude 会自动压缩历史。

- • **手动干预**：使用 `/compact <指令>`（如 `/compact 聚焦 API 改动`）自定义压缩重点。
- • **规则固化**：在 `CLAUDE.md` 中约定压缩时必须保留的信息（如：当前修改的文件列表）。

### 2. 使用 Subagents 隔离复杂度

将发散性的调查工作外包给子 Agent，保持主对话干净。

> **示例**："启动 Subagent 调查认证系统的 token 刷新逻辑，并返回摘要。"  
> Subagent 在独立窗口运行，其产生的冗杂日志不会消耗主对话的上下文水位。

### 3. 使用 Checkpoints 回滚

- • Claude 改动前会自动创建检查点。
- • 支持仅恢复对话、仅恢复代码或同时恢复。
- • **场景**：适合高风险尝试，不行就瞬间回滚。

---

## 四、配置环境：持久化知识的分层设计

### 1. CLAUDE.md - 全局规则

每次会话自动加载。使用 `/init` 生成模板。

|✅ 应当包含（高信噪比）|❌ 应当排除（低价值噪声）|
|---|---|
|无法通过代码推断的定制 Bash 命令|已经显而易见的标准语言规范|
|与项目绑定的 Lint 或代码风格约束|频繁变动的业务文档（改用链接）|
|仓库特有的工作流（PR/分支命名）|空洞的口号（如“写清洁代码”）|
|开发环境的坑（环境变量配置）|逐文件的代码库描述|

**原则**：每行必须通过“删掉它会导致 Claude 犯错吗？”的审查。

### 2. Skills & Hooks - 按需加载与强执行

- • **Skills**：存放在 `.claude/skills/`，通过 `description` 语义匹配加载。适合存放领域知识（如特定的 API 规范）。
- • **Hooks**：确定性的自动化执行。例如：“每次保存文件后自动运行 `eslint`”。

---

## 五、工作流：四阶段分而治之

对于跨文件的复杂任务，严禁直接 Implement。

1. 1. **Explore (探索)**：Plan Mode。阅读源码，理清逻辑。
2. 2. **Plan (计划)**：Plan Mode。制定方案，产出修改清单。
3. 3. **Implement (实施)**：Normal Mode。根据计划执行并运行测试。
4. 4. **Commit (提交)**：使用 `gh` 或 `git` 提交并开启 PR。

---

## 六、有效沟通与自动化

### 1. 让 Claude 面试你

大型功能开发前，要求 Claude 对你进行深度面试。

> "我想构建 [描述]。使用 AskUserQuestion 对我进行详细面试，直到你写出一份完整的 SPEC.md。"

### 2. Headless 与并行化

- • **Headless**：`claude -p "任务描述" --output-format json`，适合集成到 CI 或自动化脚本。
- • **并行作战**：开启两个 Session，一个作为 **Writer** 编写，另一个作为 **Reviewer** 专门找 Bug。

---

## 七、避坑指南：五大失败模式

1. 1. **大杂烩会话**：在同一个会话里处理不相关的任务。**解法**：`/clear`。
2. 2. **无限纠正**：在错误的路径上反复推倒重来。**解法**：重开新会话，重写更好的初始 Prompt。
3. 3. **规则过载**：`CLAUDE.md` 堆满废话。**解法**：无情修剪。
4. 4. **信任盲区**：不提供验证工具就发布。**解法**：始终要求测试。
5. 5. **无限制调查**：让 Claude 漫无目的阅读。**解法**：限定文件范围或使用 Subagents。

![](https://mmbiz.qpic.cn/sz_mmbiz_jpg/fOBv47QeGVEn1aAHPaBIqTlYf00Y0X0Ltv9cjLNcicgnVAjBk77hpAaMkZOZuVdpIfk0EZ7kDoMdUfkqLLAL30w/640?wx_fmt=jpeg)

  
    
    这些也基本都是社区经验了，只是这下官方认证有效了
    
    @文件路径，在项目里，它不能自动出来中文路径，请问这个是需要配置什么吗？
    
    可以手动粘贴过来，一样能识别，它只是路径的自动提示有时支持不好
    
    按列表形式总结下这个最佳实践 [@元宝]
    Claude Code最佳实践核心要点：
    1. 上下文管理是根本：上下文窗口是最昂贵资源，直接影响推理精度
    2. 输入策略：按需调取而非预加载，善用@文件路径精准引用
    3. 验证驱动开发：强制运行测试、图像比对和输出校验确保质量
    4. 及时止损机制：发现偏差立即Esc终止，严重时/clear重置会话
    5. 分阶段工作流：严格遵循Explore→Plan→Implement→Commit四步法
    6. 配置环境优化：CLAUDE.md只保留关键规则，使用Skills和Hooks分层管理知识