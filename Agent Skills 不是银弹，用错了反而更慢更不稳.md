
第一次在杭州下雪天开车，真的无语死了。刚开出没多久，就堵在文一路晚高峰里，一动不动。

后排乘客一直吐槽”这垃圾路况，又得浪费一个半小时“。

我没吭声，默默掏出 MBP，连上手机热点，打开 CC，敲下 `/traffic-skill`:

它开始自动获取五公里内的红绿灯配时、路口排队长度、车流拓扑和可绕行路径。不到十秒，它生成了新的信号联动策略， push 到云端。

1 分钟后，车队像泄洪的水一样快速流动，我一路绿灯穿过拥堵区，车速拉到 60，爽。

乘客问我刚才干了啥。

我只是笑笑，说：“这雪，好美。”

梦醒了，我摸摸笑疼的下巴，该去写我的 Skills 了。没错，就是那个不写不是 AI 人的 Agent Skills。

---

## Skills 火的离谱

Skills 的热度让我想起 MCP 刚出圈那会儿：一夜之间，人人都在搞“万物皆可 Agent”。一片火热。

但是火热的背后，更大程度上是 Skills 被神化成了“全能”，我们看到成千上万的 Skills——有一堆是看似很酷、实际很虚的东西：连“把字符串转大写”都要写个 Skill，恨不得把每一步都交给模型“理解一下”。

这就是路走歪了，虽然可以解决问题，但是绕了个大圈子，而且很容易把小白带进坑里：**把确定性工作重新变回不确定性**。

而这，违背了 Skills 的设计初衷。

---

## Skill 到底是什么

官方的定义很直白：

> 在 Claude Code 里放一个 `SKILL.md`，让 Claude 把它当“工具箱里的一把工具”。 该用的时候它会用，你也可以主动触发。

一句话就是 **Skill 是“扩展能力的工具”。**

它擅长：

- **判断与取舍**：要不要做、优先做什么、怎么分类怎么命名
    
- **编排与协作**：把多个步骤/多个工具串起来，形成可复用流程
    

它不擅长：

- **高频且确定性的步骤**
    
    ：每次都一样、结果可验、失败可定位的那种
    

---

## Skills 滥用

很多人把 Skill 当成“封装”，这没错。但是它是靠大模型**一次又一次的推理**前进的，如果设计错了，那么其会变成拖累。而在现在这个啥都要做成 Skill 的风口，滥用已经凸显，主要体现在：

### 1）慢

每次调用 Skill，几乎都意味着：

- 模型再读一遍上下文、理解需求
    
- 再判断“该不该用这个 Skill”
    
- 再发起工具调用/外部请求
    
- 再把结果读回来、解释给你
    

原本 1 秒能干完的事，套上 Skill 变 10 秒。

低频、可忍耐等待、且能明显省脑力的任务，慢一点没问题；但高频任务要这样就会把人磨死。

### 2）不稳

Skill 的本质是：把大模型引入流程中。大模型的输出天然不确定——你写得越模糊，它越可能在：

- “该不该用”上犹豫
    
- “怎么用”上发散
    
- 失败后“自我修复”越修越歪
    

如果结果可验、失败可定位，那不稳还可控；如果结果不可验（比如生成内容），那的必须用规则把它钉住。

### 3）上下文膨胀

这是最隐蔽的，尤其对于收藏党，看到这也好那也好：往工具箱里塞的“说明书”越来越多，结果 Skills 重叠、上下文膨胀，反倒影响了质量。

---

## 选不选 Skills，是个问题

如果你也纠结“如何判断一个功能或流程是否适合做成 Skill”，那么看三个维度：

- **频次**：用得越多，越应该压低边际成本
    
- **确定性**：越确定、越可验，越应该“编译”成代码/脚本
    
- **不确定性**：需要取舍、归类、总结、改写等抽象型的，才适合交给模型
    

一个 Skill 的使用成本是：**总成本 = 调用频次 ×（推理 token + 工具等待 + 失败重试），不确定性才是整个流程的瓶颈。**

> 频次越高，就越不该把“确定性步骤”留在模型里反复推理，这样只会让你的 Skill 华而不实。

下面用三个我自己经历的真实需求，来把”是否适合选 Skill 来实现“讲透。

---

### 例子一：把高频确定性工作流“编译”成脚本

**需求**：给一个“免费的书籍共享网站”的链接，自动下载书籍，然后上传到微信读书。

**这条链路的特征**：

- 步骤固定（打开 → 下载 → 上传）
    
- 输入结构化（链接/账号/格式）
    
- 高频（你收藏的速度通常比你读书快）
    
- 目标明确（成功/失败一眼可知）
    

如果用 Skill 也能做，但会付出“越用越贵”的代价：

- 每次都要模型重走推理链
    
- 每次都要付 token 和等待
    
- 失败后还得看模型“自我纠错”
    

最后的结局通常是：**越用越烦，然后弃用。**

更好的方法是：

> **先让 AI 跑通流程 → 再让 AI 把流程总结成脚本 → 脚本稳定后彻底脱离模型。**

脚本一旦成型，那完全是不花钱、稳定且快速执行的东西，这不比看大模型吭哧吭哧的好。

**所以，别把“确定性的高频链路”交给模型，这样费时费钱。**

![skills-122.png](https://mmbiz.qpic.cn/sz_mmbiz_png/fOBv47QeGVHicsYtdXERFEd6KibmGrtChCGrXaEiaseZAg7ONRZrLPkdLp3EdcWLpfPSLBatNcxlfGx3tTDlF8UMg/640?wx_fmt=png&from=appmsg)

---

### 例子二：脚本/资源 + AI = Skill

**需求**：把网页文章保存到本地 Markdown，保留样式和图片，最后再做分析（摘要、标签、归档、精读要点）。

**背景**：很多站点限制爬虫，模型的 web fetch 也经常拿不到完整内容。

这类任务拆分下：

**确定性的东西（适合脚本）：**  
抓取、清洗、转 Markdown、落盘、缓存、重试。

**不确定性的东西（适合 Skill）：**  
摘要、标签、归类、命名、要不要精读、要不要保留某段落。

最稳的做法是：

> 用户丢链接 → Skill 判断来源与策略 → 调用本地脚本抓取并缓存 → Skill 做摘要/标签/标题 → 输出 Markdown 路径 + 分析结果

这种类型的任务的做法就是内化脚本，和大模型结合使用，而不是就一个 SKILL.md。

---

### 例子三：抽象程度高的事务 = Skill（Subagent）

**需求**：Dan Koe 风格文章生成器（选题 → 结构 → 金句 → 删废话 → 迭代到可发布）。

这种事，脚本写不出来，写出来也没用。

因为输入输出都不确定：

- 输入不是参数，是“观点碎片/情绪/立场/语气”
    
- 输出不是对错题，是“值不值得转发、读完会不会爽”
    

它的本质不是“执行流程”，而是**持续做取舍**：

- 哪个角度最刺痛读者
    
- 哪句话该更狠、哪段该删
    
- 哪个比喻能让小白秒懂
    

针对这一类的做法就是分工：

- **Skill**：固化“评价标准”（结构、节奏、信息密度、删废话规则）
    
- **Subagent**：扮演“主编/毒舌审稿人”，强制迭代 2～3 轮
    
- **脚本**：做发布前检查（标题长度、小标题长度、字数、格式）
    

> **脚本解决“能不能做”，Skill/Agent 解决“该不该、怎么更好”。**

---

## 把“选型”也做成一个 Skill

如果你看完还是纠结：这到底适合做成Skill吗？有没有更好的组织形式？那么可以使用下下面的Skill来辅助你思考和选型，帮你选是 MCP、Skill、Subagent 还是脚本，直接把需求丢给它，它会按维度给出建议。

这个 Skill `advising-architecture`核心思路就是：  
**按频次×确定性×可验证性**去推荐 MCP / Skills / Subagents / Scripts 或混合方案。

（下面的Skill.md 仅为预览，完整版见链接 https://my.feishu.cn/wiki/VggLwFVmQiAxD7klAK8crrjHncb?from=from_copylink。）

```markdown
---
name: advising-architecture
description: Recommend MCP / Skills / Subagents / Scripts (or hybrid) by analyzing frequency, determinism, verifiability, and maintenance cost.
---
# Advising Architecture## Inputs it should ask
- What’s the goal? What does “done” look like?
- Frequency: per day/week/month?
- Verifiability: can success/failure be asserted automatically?
- Determinism: are steps fixed and repeatable?
- Tolerance: latency acceptable? retries acceptable?
- Integration: which tools/services/files involved?
## Output
- Recommended approach + why
- What to script vs what to keep in Skill
- Minimal implementation plan (next 3 steps)
```

---

## 最后

不要盲信他人的 Skill，要做自己的 Skill。分享下我个人采用的方法：

1. **先让模型跑通一次**：把流程走通，暴露不确定点。
    
2. **把确定性步骤编译出去**：能脚本化就脚本化，能工具化就工具化。
    
3. **Skill 只留下判断与编排**：触发条件写死、禁用场景写死、输出模板写死。
    

这就是为何 Skill 的设计有个 scripts 和 assets 的设计，目的就是：

> 把确定性交给代码（脚本），把不确定性交给大模型。

至于代码怎么写，聪明如你，通过 AI Coding 生成，让其生成和调试直到达到效果，再之后就是每次执行了，免费、快速、稳定，岂不乐哉？！

不要在单 SKILL.md 上止步不前，不要单兵作战。

确定性和不确定性不仅帮你做好实现方案，更会帮你理清思路。

  

#AI #ClaudeCode #AICoding #VibeCoding #Skill.md #Skills