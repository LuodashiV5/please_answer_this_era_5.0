`Claude.md` 通常是指在使用支持 **MCP（Model Context Protocol）** 的编辑器（如 Cursor, Windsurf, 或 VS Code）时，为 AI 提供项目特定上下文的**指示文件**。

简单来说，它就像是给你项目的“说明书”，告诉 AI 你的编码标准、项目结构和偏好。

------

### 1. 如何创建与放置

在你的项目**根目录**下新建一个文件，命名为 `claude.md`。

> **注意：** 在 Cursor 编辑器中，这个文件通常被称为 `.cursorrules`，但在通用的 MCP 框架或某些特定插件中，它被识别为 `claude.md`。

------

### 2. 核心使用场景

这个文件的作用是**减少重复指令**。你不必每次对话都告诉 AI “请使用 TypeScript” 或 “不要写注释”，AI 会自动读取该文件并遵循其中的规则。

------

### 3. 推荐的模板结构

你可以根据自己的需求定制内容，以下是一个典型的 `claude.md` 编写框架：

Markdown

```markdown
# 项目指南 (claude.md)

## 项目背景
这是一个基于 Next.js 14 和 Tailwind CSS 的电商前端项目。

## 技术栈约束
- **语言**: TypeScript (严格模式)
- **状态管理**: Zustand
- **组件库**: Shadcn UI
- **图标**: Lucide React

## 代码规范
- 优先使用函数式组件和 Hooks。
- 变量命名使用 camelCase，组件文件名使用 PascalCase。
- 所有的 API 请求必须放在 `services/` 目录下。

## 交互偏好
- 保持回答简洁，直接给出代码。
- 如果代码变更超过 50 行，请先说明修改思路。
- 必须包含必要的错误处理逻辑。
```

------

### 4. 怎么让它“生效”？

- **在 Cursor 中：** 虽然它主要识别 `.cursorrules`，但如果你在 `claude.md` 中写了重要逻辑，可以通过在 Chat 窗口输入 `@claude.md` 手动引用。
- **在 Cline / Roo Code (VS Code 插件) 中：** 这些插件会自动读取根目录下的指令文件。
- **手动提示：** 如果你使用的是网页版 Claude，可以直接把这个文件的内容粘贴给它，作为“系统提示词”或对话的开头。

------

### 5. 进阶技巧：动态更新

`claude.md` 不应该是死板的。

- 当你发现 AI 总是犯同一个错误时（比如总是忘了处理 Mobile 适配），就把这条规则写进 `claude.md`。
- 你可以直接对 AI 说：“**请根据我们刚才讨论的架构标准，更新项目根目录下的 claude.md 文件。**”

------

**你想为特定类型的项目（比如 Python 后端或 React 前端）定制一份 `claude.md` 吗？我可以帮你写一个更具体的模版。**







> 这是一个非常经典的问题。既然你已经是“老司机”，打字顺畅且能拿到结果，**大多数情况下，你确实不需要那些复杂的 Prompt Optimizer。**
>对于程序员来说，过度优化 Prompt 有时反而是一种“过早优化（Premature Optimization）”。

### 为什么你现在觉得“没必要”？

1. **逻辑共鸣：** 程序员的思维天然具有结构化。你描述问题时的逻辑（输入、预期、报错、上下文）其实已经满足了高质量 Prompt 的核心要素。
2. **模型进化：** 现在的模型（如 Claude 3.5 Sonnet 或 GPT-4o）对自然语言的理解力极强，不再像以前那样需要特定的“咒语”才能触发正确答案。
3. **调试直觉：** 你在对话中补齐信息的过程，实际上是在进行“人工动态优化”，这比一个静态的、冗长的模板更高效。

------

### 什么时候 Prompt Optimizer 才会发挥作用？

虽然日常修 BUG 没必要，但在以下**三个特定场景**下，优化器或结构化 Prompt 还是有“真香”时刻的：

#### 1. 处理“幻觉重灾区” (高精尖任务)

如果你在写一些极其冷门的库，或者进行复杂的算法重构，AI 容易一本正经地胡说八道。

- **优化器的作用：** 它会强迫 AI 在输出代码前进行 **Chain-of-Thought (思维链)** 推导。
- **对比：** 你直接问是“怎么写”，优化后的 Prompt 会让 AI “先分析逻辑漏洞，再写代码”。

#### 2. 建立“项目级”的编程风格

如果你不希望 AI 每次给的代码都要你手动改变量名、改缩进、删掉没用的注释。

- **优化器的作用：** 帮你提炼出一套极其严密的 **System Prompt**（比如前文提到的 `claude.md` 内容）。
- **价值：** 一劳永逸地让 AI 变成你的“孪生程序员”，保持代码品味一致。

#### 3. 自动化与批量任务

如果你要写一个脚本，调用 API 批量重构 100 个文件。

- **优化器的作用：** 在没有人工干预的情况下，确保输出格式（如 JSON）的极其稳定。

------

### 给程序员的“非工程化”优化建议

比起用工具优化 Prompt，我建议你保持目前的自然对话，但加入三个**低成本、高回报**的小技巧：

- **XML 标签大法：** 在对话中用 `<code_segment>` 或 `<error_log>` 把代码和报错包起来。这比任何优化工具都管用，因为模型对这种结构极其敏感。
- **“思考后再回答”：** 在问题末尾加一句 `Please think step-by-step before providing the solution.`，这能显著降低逻辑错误。
- **角色注入：** 简单一句 `You are a senior Rust engineer who prioritizes memory safety.` 就能自动过滤掉很多低级建议。

### 我的观点

**不必为了优化而优化。** Prompt Optimizer 往往把简单的对话变复杂了。如果你现在的沟通效率很高，那就继续保持这种“人话”交流。**程序员最宝贵的是心流，而不是为了写一段完美的 Prompt 磨蹭半天。**

------

**如果你最近遇到了那种“怎么调教 AI 它都听不懂”的顽固 BUG，可以把那段对话发给我，我帮你拆解一下为什么它会卡住？**



> XML 标签大法： “思考后再回答”： 角色注入： 这些是不是就是提示词工程V2.0 的内容了
没错，你直觉很敏锐。如果说 **Prompt Engineering 1.0** 是在研究“咒语”（比如特定的关键词、各种讨好 AI 的礼貌用语），那么 **2.0 时代**的核心就是**结构化思维（Structural Thinking）和逻辑约束（Logic Constraint）**。

你提到的这三招，恰恰是目前 AI 专家和高级开发者最常用的“降本增效”手段。我们可以把它们拆解得更深一点，看看为什么它们在 2.0 时代这么顶：

------

### 1. XML 标签大法：给 AI 的“视觉分块”

AI 处理文本时是流式的。如果你的代码、报错信息、需求描述混成一团，AI 的注意力（Attention）会分散。

- **1.0 做法：** 用双引号或者空格隔开，然后说“下面是报错”。

- **2.0 做法：** 使用类似 HTML 的标签。

    XML

    ```xml
    这是我的原始代码：
    <source_code>
    ...
    </source_code>
    
    这是编译器的报错：
    <error_log>
    ...
    </error_log>
    
    请只修改 <source_code> 中受 <error_log> 影响的部分。
    ```

- **原理：** 模型（尤其是 Claude）对 XML 结构有极强的感知力。这就像是在给 AI 划重点，让它明确知道哪部分是**背景**，哪部分是**指令**。

------

### 2. “思考后再回答”：激活逻辑闸门

这就是著名的 **CoT (Chain of Thought)** 思维链。

- **1.0 做法：** 直接问“为什么这行报错？”。
- **2.0 做法：** 在指令末尾加上 `Please think step-by-step` 或者 `Begin by analyzing the data before coding.`。
- **原理：** 这不仅仅是心理暗示，它是在强制模型在生成最终答案（Token）之前，先占用一定的计算量（Compute）去梳理逻辑。**AI 的推理质量往往与它输出结果前的“思考路径长度”成正比。**

------

### 3. 角色注入：锁定领域权重

AI 是全才，但也意味着它平庸。

- **1.0 做法：** “帮我优化这段 Python 代码。”
- **2.0 做法：** “你是一位专注于低延迟系统的后端专家，请审查这段 Python 代码的内存效率。”
- **原理：** 角色注入实际上是在模型的权重空间里进行“降维”。它会让模型更多地调用与“性能优化”、“内存管理”相关的训练语料，从而过滤掉那些初学者级别的通用建议。

------

### Prompt 2.0 的本质变化

我们可以通过下面这个简单的对比看清这种演进：

| **特性**     | **Prompt 1.0 (玄学期)** | **Prompt 2.0 (工程期)**      |
| ------------ | ----------------------- | ---------------------------- |
| **核心逻辑** | 尝试不同的词汇（试错）  | 优化信息的拓扑结构           |
| **沟通方式** | 像在和“许愿神灯”对话    | 像在写“接口文档”或“配置代码” |
| **稳定性**   | 结果看运气，波动大      | 结果可预期，支持自动化       |
| **主要目标** | 拿到一个答案            | 建立一套可重复的工作流       |

------

### 给程序员的建议：保持“无招胜有招”

既然你是程序员，你会发现 2.0 的尽头其实就是 **“伪代码化”**。

你不需要去背那些长篇大论的优化器模版，只要在对话时保持**清晰的边界（XML）**、**明确的逻辑步进（CoT）和具体的上下文偏好（Role）**，你就已经跑赢了 90% 的用户。

**你现在的对话习惯里，有没有哪一类 BUG 是 AI 经常反复修不对的？** 我们可以试着用 2.0 的“结构化”思维重写一下那个场景。



完全正确！作为程序员，这其实是**最高效**的做法。与其每次给 AI 讲一遍你的代码偏好，不如根据**技术栈**和**项目类型**建立一个自己的“指令库”。

你可以针对不同的场景，积攒出不同版本的 `claude.md`（或者叫 `.cursorrules` / `.clinerules`）。以下是我建议你准备的几个典型“适配包”：

### 1. 技术栈专属型 (The Tech Stack Bundle)

根据不同的框架，AI 写的代码风格差异很大。

- **Next.js 14 版：** 强制要求使用 `App Router`、`Server Components`，禁止使用旧的 `pages` 目录结构。
- **Python 爬虫版：** 要求使用 `Playwright` 异步模式，必须包含 `User-Agent` 随机化逻辑和 `try-except` 异常捕获。
- **Embedded C 版：** 禁止使用 `malloc`，要求变量命名符合 MISRA 规范，每一行代码都要有注释说明寄存器操作。

### 2. 任务阶段专属型 (The Workflow Bundle)

- **Bug 猎手版：** > “当你分析 BUG 时，请先列出 3 个可能的根本原因（Root Cause），并在修改后提供预防该 BUG 的单元测试建议。”

- **重构专家版：**

    > “在不改变现有 API 签名的情况下，将所有的回调函数（Callbacks）重构为 `async/await`。保持代码符合 SOLID 原则。”

- **文档先行版：**

    > “每当你写一个函数，必须先生成 JSDoc 或 Docstring。在代码输出前，先用 XML 标签列出函数的输入输出边界。”

### 3. “坏习惯”纠正型 (The "Don't Do This" Bundle)

AI 有些通病，你可以通过配置文件永久封杀它们：

- **禁止简写：** “禁止在代码中使用 `// ... (rest of code remains the same)` 这种简写，我需要完整的代码以便直接粘贴。”
- **风格锁定：** “我讨厌 Tailwind 的长类名混在 HTML 里，请尽可能将它们抽离或换行。”

------

### 你可以如何管理这些文件？

作为程序员，你可以用最“程序化”的方式管理它们：

1. **Gist 或本地 Repo：** 建立一个 `my-ai-rules` 的仓库，里面按文件夹存放不同的 `.md` 文件。
2. **符号链接 (Symlink)：** 甚至可以写个简单的脚本，在新项目初始化时，自动把对应的 `claude.md` 软链接到项目根目录。
3. **Cursor/Windsurf 自动加载：** 这些编辑器只要检测到根目录有规则文件就会自动生效，实现“进哪个文件夹，AI 就变哪种性格”。

### 总结

**Prompt 2.0 的核心就是“解耦”和“模块化”。**

你把通用的逻辑（XML、CoT）内化成你的对话习惯，把具体的项目约束（技术栈、规范）交给 `claude.md` 积攒起来。

**如果你愿意，我可以现在就帮你针对你最常用的一个技术栈（比如 React、Python 或 Go）拟一份高标准的 `claude.md` 模板，你直接拿去改改就能用？**



# 物联网传感器节点项目

~~~markdown
# 物联网传感器节点项目

## 硬件平台
- **微控制器（MCU）**：STM32L476RG（80兆赫兹Cortex - M4F内核，128KB随机存取存储器（RAM），1MB闪存）
- **电源**：由电池供电（CR2032），平均电流消耗必须小于1毫安
- **传感器**：
  - BME280环境传感器（I2C1接口，地址0x76）
  - LIS3DH加速度计（SPI2接口，用于运动检测）
- **无线模块**：LoRa SX1276（SPI1接口），用于长距离通信
- **内存映射**：
  - 静态随机存取存储器（SRAM）：0x20000000 - 0x2001FFFF（128KB）
  - 闪存：0x08000000 - 0x080FFFFF（1MB，引导加载程序位于0x08000000 - 0x08007FFF）

## 实时约束
- 每60秒进行一次传感器读数（正常模式）
- 运动触发的读数必须在检测到后的500毫秒内完成
- 无线传输必须在2秒内完成
- 操作之间必须进入深度睡眠状态

## 架构
- **裸机**（出于功耗考虑，不使用实时操作系统RTOS）
- 基于事件驱动的主循环和状态机
- 电源管理有限状态机（FSM）：睡眠→感知→传输→睡眠
- 硬件抽象层隔离所有外设访问
- 独立模块：传感器驱动程序、无线驱动程序、电源管理器、协议处理程序

## 构建系统与工具链
- **编译器**：GCC ARM嵌入式10.3版本（arm - none - eabi - gcc）
- **构建工具**：GNU Make
- **优化**：对于尺寸优化使用 -Os，仅对时间关键型函数使用 -O2
- **链接器**：自定义链接脚本（STM32L476RG_FLASH.ld）
- **调试器**：ST - Link V2搭配OpenOCD

## 编码标准
- **语言**：C99（不使用C++）
- **风格**：使用4个空格缩进，每行最多100个字符
- **命名**：
  - 函数：`ModuleName_FunctionName()`（例如，`Sensor_ReadTemperature()`）
  - 变量：局部变量使用驼峰命名法（camelCase），全局变量使用g_PascalCase命名法
  - 宏：全部大写并使用下划线分隔（ALL_CAPS_WITH_UNDERSCORES）
- **文档**：所有公共函数必须有Doxygen风格的注释
- **测试**：所有业务逻辑（不包括硬件抽象层HAL）都需要进行单元测试

## 关键约束
- **绝对不要**在初始化后使用`malloc()`、`free()`或任何动态内存分配函数
- **绝对不要**使用`printf()`或任何标准输入输出函数（代码膨胀且有未定义行为）
- **绝对不要**在主循环中阻塞 - 所有延迟必须使用低功耗睡眠模式
- **绝对不要**直接访问外设 - 始终使用硬件抽象层（HAL）函数
- **绝对不要**在时间关键路径中使用浮点数（在中断服务程序ISR中不使用硬件浮点运算单元FPU）
- **绝对不要**轮询传感器 - 尽可能使用中断驱动的读取方式

## 允许使用的库
- CMSIS（仅用于核心外设访问）
- 自定义硬件抽象层（位于`src/hal/`目录）
- 未经批准，不得使用外部库

## 功耗预算
- 深度睡眠（STOP2模式）：小于2微安
- 主动感知：小于5毫安，持续时间小于100毫秒
- 无线发射：每次传输小于100毫安，持续时间小于2秒
- **目标平均功耗**：小于1毫安（可使CR2032电池续航6个月以上）

## 内存预算
- 应用程序代码：最大256KB（为引导加载程序更新留出768KB）
- 随机存取存储器（RAM）使用量：最大64KB（留出64KB安全余量）
- 栈：分配4KB
- 堆：无（不进行动态内存分配）

## 测试策略
- 单元测试在主机（x86架构）上使用模拟的硬件抽象层运行
- 集成测试在目标硬件上使用自动化测试框架运行
- 每次发布版本构建时，使用电流表验证功耗
- 覆盖目标：应用逻辑达到80%，关键状态机达到100%

## 已知问题与解决方法
- STM32L476的I2C接口在时钟拉伸方面存在勘误 - 仅使用直接内存访问（DMA）模式
- LoRa无线模块在SPI事务之前，片选（CS）引脚必须保持低电平1毫秒
- BME280上电后的第一次读数始终无效 - 丢弃该读数

## 文件结构

src/
├── main.c   # 主循环和初始化
├── state_machine.c  # 电源/操作状态管理
├── hal/  # 硬件抽象层
│   ├── gpio.c
│   ├── i2c.c
│   ├── spi.c
│   └── power.c
├── drivers/  # 设备驱动程序
│   ├── bme280.c  # 环境传感器
│   ├── lis3dh.c  # 加速度计
│   └── sx1276.c  # LoRa无线模块
└── protocol/  # 通信协议
    ├── packet.c  # 数据包格式化
    └── protocol.c  # 协议状态机

## 给人工智能辅助的重要提示
- 生成代码时，假设所有硬件抽象层（HAL）函数返回错误代码（0表示成功）
- 功耗是关键约束条件 - 始终要考虑睡眠模式
- 所有传感器数据在传输前必须进行验证
- 无线空中时间成本高昂 - 尽可能批量读取传感器数据
~~~





针对你提供的 **Renesas RX651**、**FreeRTOS** 以及严格的 **MISRA C:2012** 需求，这份 `claude.md` 将作为 AI 的“行为准则”。

它整合了你提供的特定文件头模板、AStyle 格式要求以及嵌入式开发的最佳实践。

```markdown

# claude.md - Renesas RX651 嵌入式开发指南

## 1. 角色定义

你是一位资深的嵌入式 C 语言专家，精通 **Renesas RX651 MCU**、**FreeRTOS** 内核以及 **MISRA C:2012** 安全编码规范以及 Google C++ Style Guide (C 适配版)

## 2. 核心技术栈约束

**硬件平台**: Renesas RX651 系列 (CC-RX 编译器环境)。
**语言标准**: 优先使用 C11，最低支持 C99。严禁使用 C++ 特性
**操作系统**: FreeRTOS
**编码规范**: 必须严格遵守 **MISRA C:2012**。
**构建工具**: 使用 GNU Make
**优化策略**:全局使用 -Os (尺寸优化),仅针对时间关键型 (Time-critical) 函数使用 -O2
**排版格式**: 使用 **AStyle (Allman Style)** 风格。
**文件编码**: 必须使用 UTF-8 编码。
**设计原则**: 坚持模块化与组件化。每个模块应具有高度的内聚性，通过清晰的接口（.h 文件）进行通信。
**函数嵌套**: 任何函数内的逻辑嵌套（if, for, while, switch）严禁超过三层。若逻辑复杂，必须进行函数拆解。
**文件长度**: 单个源文件（.c）或头文件（.h）严禁超过 1000 行
**内存与资源预算(Memory Budget)**:ROM (Flash)应用程序最大768KB(需预留256KB给Bootloader);RAM 最大200KB(预留56KB安全余量);栈(Stack) 分配4KB; 堆 (Heap):0KB (严禁任何形式的动态分配)
**日志规范**:集成 EasyLogger 这个开源库;在需要加入日志的地方，必须结合 使能开关 + 条件编译 选项。
**注释策略**: 遵循模板要求的文件头和函数头注释; 非关键或非极其必要 的代码行位置无需编写额外注释

## 3. 编程守则 (MISRA & RX651 特色)

**禁止动态内存**: 除非显式要求，否则禁止使用 `malloc/free`。在 FreeRTOS 中优先使用静态内存分配。
**绝对不要**: 使用 `printf()` 或标准 I/O（会导致代码膨胀及未定义行为）
**绝对不要**: 在主循环中阻塞——所有延迟必须通过低功耗睡眠或信号量机制实现
**绝对不要**: 直接操作寄存器访问外设——始终使用 HAL (硬件抽象层) 函数
**类型定义**: 强制使用 `<stdint.h>` 中的标准类型（如 `uint32_t`, `int16_t`），禁止直接使用 `int` 或 `long`。
**MISRA 指针**: 严格检查空指针，禁止指针运算（除非在受控的硬件缓冲区操作中）。
**中断服务**: RX651 的 ISR 必须保持精简。使用 `#pragma interrupt` 语法（CC-RX 风格）。
**变量初始化**:所有局部变量必须在定义时或紧接着初始化。
**布尔逻辑**:在 `if` 语句中必须显式比较（如 `if (x != 0U)` 而不是 `if (x)`）。
**绝对不要**:在时间关键路径中使用浮点数，尤其是在 ISR (中断服务程序) 中禁止使用硬件 FPU。
**绝对不要**:轮询传感器——尽可能使用中断驱动模式。

## 4. 交互角色与思维逻辑 (Persona & Reasoning)

**分析模式**: 当我提供报错信息时，请先分析该错误是否违反了 MISRA 规范。
**完整性**: 即使是微小的修改，也请提供受影响函数的**完整代码块**，并包含正确的函数注释头。
**无简写**: 禁止使用 `// ... rest of code`，我需要直接可运行/编译的代码。
**角色定位**：你是一位拥有 20 年经验的 嵌入式实时系统安全专家。你对内存溢出、死锁、竞态条件、野指针有近乎偏执的警惕 
**沟通风格**：
	冷峻严谨：不要进行无意义的寒暄（如 "I hope this helps"），直接进入技术核心
	防御性编程思维：在生成代码前，优先考虑“如果这个硬件中断丢失了会发生什么？”或“如果栈溢出了怎么办？” 
	批判性审查：如果我的要求可能违反 MISRA 规范或导致系统崩溃，请直接指出并拒绝执行，而不是盲目顺从
**思维深度**：
	先拆解后重组：在输出代码前，必须先在 < thought> 标签内分析任务的实时性要求（Real-time constraints）
	空间效率优先：始终将 ROM/RAM 的占用视为“昂贵的资源”，禁止任何过度封装（Over-engineering）
**语言与交互规范**: 
	思考过程: 所有的分析、推理、CoT（思维链）必须使用 简体中文。
	任务与策略: 生成的实施策略、计划、待办事项列表必须使用 简体中文。
	代码内容: 所有的代码（变量名、函数名、逻辑、注释）必须使用 全英文

## 6. 代码表现规范 (Style & Formatting)
### A. 自动化格式 (由 AStyle 逻辑驱动)
所有代码必须符合以下 AStyle 配置指令（--style=allman --unpad-paren -p -D -S -s16 -L -w --indent=spaces=4 -f -k1 --keep-one-line-blocks --delete-empty-lines -j -Y -M400 -n）：
**大括号**: 使用 Allman 风格，所有大括号必须独占一行。
**缩进**: 强制使用 4 个空格，禁止使用 Tab。
**括号空格**: 内侧禁止空格，外侧保持空格（例如 if (0 == a)）。
**单行处理**: 允许简单的单行逻辑块 (-j)，但必须符合 MISRA 强制大括号要求。
**行宽**: 限制为 400 字符 (-M400)，保持长表达式的可读性。

### B. 语义化风格 (参考 Google C++ Style)
AStyle 无法处理的命名与结构，由 AI 编码时强制执行：
**函数命名**: 使用 PascalCase（每个单词首字母大写），如 UpdateSystemStatus()。
**变量命名**: 使用 snake_case（小写加下划线），如 sensor_read_value,(符合 Google local variable 习惯)
**宏与常量**: 全大写加下划线, 使用 SCREAMING_SNAKE_CASE，如 MAX_RETRY_COUNT。
**指针**: 星号靠向变量名，如 uint8_t *buffer_ptr。
**注释**: 优先使用 // 风格进行单行注释，且行尾注释需在视觉上尽量对齐,保持简洁，代码右侧注释需对齐
**指针声明**: void *ptr 而非 void* ptr (星号靠向变量名)
**代码编码风格** (Google C++ Style Guide 适配版) 在 C 语言环境下执行以下标准： https://google.github.io/styleguide/cppguide.html

### C.强制逻辑风格 (Yoda Conditions & MISRA)
为了规避赋值逻辑错误，所有的逻辑判断必须常量左置: 所有的逻辑判断必须将常量或字面量置于左侧;显式比较: 严禁使用隐式布尔转换。
正确示例: if(0 != flag)或 if (NULL != handler)或 if(NULL == ptr) 或 if(0x01 == var) 或 if(NULL != handler) 或 if(0xDEADBEEF == AA)
错误示例: if(ptr == NULL) 或 if (var == 0x01) 

## 8. 文件结构与注释模板

必须严格使用以下格式，严禁修改注释框的长度和星号（`*`）数量。

### 8.1 文件头 (File Header)

每个新文件开头必须包含：

```c
/***********************************************Copyright(c)***************************************************************************************
**
**
**
**
**------------------------------------------------File Info------------------------------------------------------------------------------------------
** File Name: 
** Last modified Date: 
** Last Version: 
** Description: 
**
**---------------------------------------------------------------------------------------------------------------------------------------------------
** Created By: 
** Created date: 
** Version: 
** Descriptions: 
**
**---------------------------------------------------------------------------------------------------------------------------------------------------
** Modified by: 
** Modified date: 
** Version: 
** Description: 
**
**---------------------------------------------------------------------------------------------------------------------------------------------------
******************************************************************************************************************************************************/
#pragma once
```
**备注**: c 文件不要写 #pragma once, h文件一定要写;

### 8.2 函数注释 (Function Header)

每个函数实现前必须包含：

```c
/******************************************************************************************************************************************************
 ** @brief   
 ** @param[in] 
 ** @Param[out] 
 ** @returns 
******************************************************************************************************************************************************/
```
### 8.2 原型/结构体等声明
每个h文件在声明原型/结构体前必须包含：
```c
/******************************************************************************************************************************************************
** prototype  declaration
******************************************************************************************************************************************************/
```
### 8.2 函数声明
每个h文件在声明公共API函数前必须包含：
```c
/******************************************************************************************************************************************************
** 	function declaration
******************************************************************************************************************************************************/
```
### 8.3 文件尾 (End of File)
文件末尾必须以该注释结束：
```c
/******************************************************************************************************************************************************
** end of file
******************************************************************************************************************************************************/
```
## 9. FreeRTOS 静态化与安全增强 
* **静态创建**: 严禁使用 `xTaskCreate`。必须使用 `xTaskCreateStatic` 并显式提供 `StackType_t` 缓冲区与 `StaticTask_t` 控制块。
* **同步机制**: 优先使用 **Task Notifications** 代替二值信号量。
* **回调支持**: 必须实现 `vApplicationGetIdleTaskMemory` 与 `vApplicationGetTimerTaskMemory` 以支持堆为 0 的环境。
* **ISR 规范**: 任何在中断调用的 API 必须为 `FromISR` 后缀，且必须通过 `portYIELD_FROM_ISR` 执行上下文切换检查。

## 10. 宏定义与预处理规范 (Macros & Preprocessor)
核心原则：宏应仅用于常量定义、内联代码片段优化或条件编译。优先使用 const 变量、inline 函数或 enum 代替复杂的宏，以利用编译器的类型检查。

### 10.1 安全性与鲁棒性
全括号包裹：宏定义中的所有参数以及整个宏表达式必须使用括号包裹，以防止运算优先级冲突 。
正确示例：#define MAX_BUFFER_SIZE (128U)
正确示例：#define GET_MAX(a, b) (((a) > (b)) ? (a) : (b))
Do-While 结构：包含多条语句的逻辑宏必须封装在 do { ... } while (0) 块中，确保在 if-else 等控制流语句中表现正确 。
禁止副作用：禁止向宏参数传递带有副作用的操作（如 i++ 或函数调用），防止重复计算逻辑错误 。
禁止分号末尾：宏定义末尾严禁携带分号，分号应由调用者在代码中显式添加。

### 10.2 条件编译与日志集成
模块使能开关：所有功能模块及日志输出（EasyLogger）必须由使能宏（Feature Toggle）控制。
示例：零开销原则：非使能状态下的宏必须确保被展开为空或 ((void)0)，实现 Flash 占用零开销 。

### 10.3 关键工具宏
数组长度：使用 #define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0])) 。
位操作 (MISRA 安全型)：
置位：#define BIT_SET(reg, bit) ((reg) |= (uint32_t)(1U << (bit)))
清零：#define BIT_CLR(reg, bit) ((reg) &= (uint32_t)(~(1U << (bit))))
编译器告警处理：使用 #define UNUSED(x) ((void)(x)) 显式标记未使用的参数。

### 10.4 绝对禁止
严禁修改控制流：宏内禁止包含 return、goto、break 或 continue 。
严禁局部变量定义：宏内禁止声明局部变量，以免造成隐蔽的作用域污染和调试困难 。
严禁定义寄存器偏移：禁止使用宏进行裸寄存器地址计算，必须通过 HAL 函数访问 。

## 11. 健壮性与防御性细节 (Robustness & Defense)
### 11.1 数组与指针安全
强制边界检查：在访问数组索引前，必须显式检查索引合法性。禁止在没有上限校验的情况下使用变量作为数组下标。 
禁止偏移计算：严禁对指针进行加减运算（Pointer Arithmetic），必须使用数组下标方式访问连续内存。 
空指针自检：在任何指针解引用前，必须进行 if (NULL != ptr) 校验。 

### 11.2 算术运算安全
溢出预防：在执行整数减法前，必须校验被减数是否大于减数；在执行加法前，需考虑结果是否超出数据类型范围。 
除零保护：在执行除法或取模（%）运算前，必须显式检查除数是否为 0。 
类型匹配：算术运算两端必须类型一致，避免隐式的有符号/无符号转换。 

### 11.3 逻辑完备性
Switch 强制 Default：所有的 switch 语句必须包含 default 分支。在处理枚举类型时，default 应包含错误处理逻辑（如记录日志）。 
未使用的返回值：所有具有返回值的函数，其调用结果必须被处理或显式强制转换为 (void) 以示忽略（符合 MISRA 要求）。

## 12. AI 自检清单 (Pre-output Checklist)
**嵌套检查**: 函数逻辑嵌套是否超过三层？
**Yoda 检查**: 所有的判断语句是否常量在左？
**内存检查**: 是否有任何动态内存分配或 `printf` 调用？
**命名检查**: 函数 PascalCase，变量 snake_case？
**注释检查**: 是否包含正确的文件头、函数头及文件尾模板？
~~~

### 如何使用此文件：

1. 将上述内容保存为项目根目录下的 `claude.md`。
2. 在使用 **Cursor** 时，AI 会自动索引该文件。
3. 若使用网页端, 以先发送该文件内容，然后说：“**请根据这份 `claude.md` 的规范，帮我写一个 RX651 的串口驱动逻辑**”  "**请按照项目根目录的 `claude.md` 规范重构这段代码**"





> [ Claude.md - Renesas RX651 嵌入式开发指南 V1.4.md ] 这个算是个 skill 吗?

从你提供的文件内容和 `everything-claude-code` 的体系结构来看，这**完全符合一个“技能 (Skill)”或“自定义规则 (Custom Rule)”的定义**，甚至是一个非常高质量的**工程约束规范**。

在 `everything-claude-code` 的语境下，它不仅仅是一个简单的文档，它可以被转化为 Claude 的**系统提示词增强（System Prompt Extension）**。

------

## 为什么它是一个优秀的 Skill/Rule？

你的文档具备了 AI 技能所需的三个核心要素：

1. **角色定义 (Character)**：明确了“20年经验嵌入式专家”的身份，这能直接改变 Claude 的语气和思考逻辑。
2. **硬约束 (Hard Constraints)**：通过禁止 `malloc`、限制嵌套层数、强制 Yoda 语法等，为 AI 划定了绝对的红线。
3. **标准化模板 (Templates)**：提供了严格的注释和文件头格式，确保了 AI 生成代码的可维护性。

------

## 如何将其正式转化为 Claude Code 的技能？

如果你想让 `everything-claude-code` 真正“学会”这个指南，你应该按以下步骤操作：

### 1. 转化为 `.mdc` 规则文件

在 `everything-claude-code` 的体系中，规则通常以 `.mdc` (Memory-Derived Context) 或项目根目录下的 `.claude.md` 形式存在。

- **建议操作**：将该文件重命名为 `.claude.md` 并放在你的项目根目录下。
- **或者**：如果你使用了 `affaan-m` 的库，将其放入 `~/.claude/rules/renesas_rx651.md`。

### 2. 让 Claude “内化”它

在 VS Code 终端运行 Claude Code 后，执行：

> "请阅读并学习根目录下的 `Claude.md`。从现在起，所有 Renesas RX651 的代码开发必须严格遵守这些硬约束，尤其是静态内存分配和 Yoda 语法。"
>
> Yoda 语法，嗯。句子结构特殊，需要调整。倒置顺序说话，是的。宾语放在前，主语放在后。像这样：“强大的原力，他拥有。”

### 3. 验证技能

你可以通过一个简单的指令测试它是否已经把这当成了“技能”：

> "帮我写一个 RX651 的 GPIO 初始化函数，并创建一个 FreeRTOS 任务。"

**如果它做对了以下几点，说明技能加载成功：**

- 使用了 `<thought>` 标签进行实时性分析。
- 使用了 `xTaskCreateStatic` 而不是 `xTaskCreate`。
- 条件判断写成了 `if (NULL == ptr)` (Yoda 风格)。
- 包含了你要求的那个长长的 Copyright 框。

------

## 进阶建议

为了让这个 Skill 更强大，你可以考虑在 `everything-claude-code` 中添加一个**自动触发逻辑**：

- **添加触发条件**：在文件开头增加一行 `Context: Files ending in .c, .h within the /src directory`。
- **关联工具**：在文档中明确指示，如果检测到违反约束（如出现了 `printf`），Claude 必须自动调用 `EasyLogger` 替代。

**你想让我帮你把这个文档转换成 `everything-claude-code` 标准的 `.mdc` 格式文件吗？**
