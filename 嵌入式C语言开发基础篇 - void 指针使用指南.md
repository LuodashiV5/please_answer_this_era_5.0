
[前篇文章](https://mp.weixin.qq.com/s?__biz=MzkxODYzNTY2Nw==&mid=2247484064&idx=1&sn=5a830f4722956e6ec2ad76b088e0c549&scene=21#wechat_redirect)简单介绍了指针的本质和几种类型的指针，其中一个无类型指针在C语言高级技巧中使用最频繁，堪称指针中的万能钥匙；今天这篇文章就来详细展开介绍。

### 一、什么是 `void *`？

在上篇指针的文章中介绍了指针的本质就是一个指向某处存储空间的地址，其单位空间大小受定义该指针的数据类型限制，本篇文章介绍的`void *`指针是一种**通用指针类型**，没有数据类型限制，只是纯粹的地址，因此可以指向任何类型的数据，但它本身**没有类型信息**，因此不能直接进行解引用或指针运算。

```c
void *p;
```

具体指向的是什么，需要由使用者显式转换后才可使用。

```c
printf("%d\n", *((int*)p));
```

------

### 二、为什么需要 `void *`？


在某些场景中，我们希望函数或结构能处理**任意类型的数据**，但又不想为每种类型都写一个接口。这时，`void *` 就派上用场了。

它的主要优势是**通用性**，但也正因如此，它牺牲了类型安全，需要开发者自己管理类型转换。

------

### 三、 `void *` 的典型作用

| 用途               | 说明                                                   |
| ------------------ | ------------------------------------------------------ |
| **通用参数**       | 允许函数接受任意类型的指针                             |
| **内存操作**       | malloc、memcpy、memset 等函数使用 void *               |
| **数据结构抽象**   | 链表、队列、栈等通用容器的节点可用 void * 存储任意数据 |
| **回调函数参数**   | 传递上下文信息时使用 void * 作为参数                   |
| **隐藏结构体实现** | 使用void *定义透明句柄，隐藏接口实现                   |

**`void*`也是C实现多态的关键；**
C语言实现多态可以查看此篇文章：[](https://mp.weixin.qq.com/s?__biz=MzkxODYzNTY2Nw==&mid=2247484071&idx=1&sn=80e024af50bda4abdcc3c8f0902918ae&scene=21#wechat_redirect);

#### 3.1 示例 1：`malloc` 返回 `void *`

```c
int *arr = (int *)malloc(10 * sizeof(int));
```

-  `malloc` 返回 `void *`，需要**强制类型转换**为目标类型。
-  在 C 中可以省略强转，编译器会做隐式转换。

------

#### 3.2 示例 2：通用函数参数，构建统一的函数接口

```c
void printValue(void *ptr, char type) {
    if (type == 'i') {
        printf("int: %d\n", *(int *)ptr);
    } else if (type == 'f') {
        printf("float: %f\n", *(float *)ptr);
    }
}
```

-  `ptr` 是一个 `void *`，可以传入任意类型的地址。
-  使用前必须根据上下文**强制转换**为正确类型。

------

#### 3.3 示例 3：链表节点中的 `void *`

```c
typedef struct Node {
    void *data;
    struct Node *next;
} Node;
```

-  `data` 可以指向任何类型的数据。
-  插入数据时需要配合 `malloc` 和强制类型转换。

------

### 四、⚠️ 使用 `void *` 的注意事项

| 限制                     | 说明                                                        |
| ------------------------ | ----------------------------------------------------------- |
| ❌ 不能直接解引用         | *p是非法的，必须先强制类型转换                              |
| ❌ 不能做指针运算         | p++、p + 1 都不允许，没有类型信息，无法确定运算后地址的指向 |
| ✅ 可以与任意类型指针互转 | 但要小心类型匹配，避免未定义行为                            |
| ✅ 可以与 NULL 比较       | 判断是否为空指针是合法的                                    |

------

### 五、类型安全的挑战



使用 `void *` 时，**编译器不会检查是否转换成了正确的类型**。这意味着：

```c
float f = 3.14;
void *p = &f;
 
printf("%d\n", *(int *)p);  // ❌ 未定义行为，类型不匹配
```

这种错误不会在编译时报错，但运行时可能导致数据错乱或崩溃。

------

### 六、总结

| 特性     | void * 行为说明                |
| -------- | ------------------------------ |
| 通用性   | 可指向任意类型                 |
| 类型信息 | 无类型信息，需手动转换         |
| 解引用   | 不允许，需先强制类型转换       |
| 指针运算 | 不允许                         |
| 类型安全 | 编译器不检查，需自行保证正确性 |

#### ✅ 使用建议

-  **封装转换逻辑**：将 `void *` 的使用封装在函数内部，避免在多个地方重复转换。
-  **配合类型标识符使用**：如传入额外的 `enum` 或 `char` 标志，指明数据类型。
-  **尽早转换为具体类型**：不要长时间持有 `void *`，转换后再操作。
-  **避免滥用**：除非确实需要通用性，否则优先使用具体类型指针。